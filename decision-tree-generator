let squares = {}
let ids = ['10010010', '01010000', '00110001', '10001000', '01001011', '00101000', '10000101', '01000100', '00100110']

for (let i = 0; i < ids.length; i++) {
    squares[i + 1] = ids[i].split('').map(x => Number(x))
}
//console.log(squares) works

//change this to change how many variations are created
const allSquares = [1,2,3,4,5]

const allVariations = []
//recursive function to generate all positions. Simply makes a path for marking squares 1->9 and provides array structure for analysis. Does include impossible variants.
const nextMove = (treeNode) => {
    //names for treeNode variables
    let path = treeNode[0].slice()
    let rSq = treeNode[1].slice()
    let xScore = treeNode[2]
    let oScore = treeNode[3]
    let nodeScore = treeNode[4]
    //console.log( `I'm the tree node path` )
    //console.log(treeNode[0])
    //console.log(treeNode)
    
    if (xScore.includes(3) || oScore.includes(3)){
        console.log('Found a win')
        console.log( path, xScore , oScore)
        return
    }else{ 
        //console.log('not a win')
        //console.log(path, xScore , oScore)
    }
    if (treeNode[1].length === 0) {
        console.log(`It's a tie`)
        //allVariations.push(treeNode[0])
        return
    }

    //console.log('Passed array length test')



    //generate array of next moves from remaining squares and add scores
    let nextNodes = []
    while (rSq.length > 0) {
        nextNodes.push([path + rSq.shift()])
    }
    //take the list of newly generated pathes and construct nodes
    for (let i = 0; i < nextNodes.length; i++) {
        let tempSq = treeNode[1].slice()
        //console.log('im the temp squares')
        //console.log(tempSq)
        //iterate through each [path] and generate remaining squares for that node.
        let nextSqNum = Number(nextNodes[i][0][nextNodes[i][0].length - 1])
        tempSq.splice(tempSq.indexOf(nextSqNum), 1)
        //push temp squares to the node after path values have been spliced out.
        //new variables for constructing next node
        let nextX = []
        let nextO = []
        let nextNodeScore = 0
        //take previous X and O scores and add new score to them
        let nextScore = squares[nextSqNum]
        //console.log('next score is....')
        //console.log(nextScore)

        if (nextNodes[i][0].length % 2 === 1) {
            //console.log('x turn')
            //console.log(nextScore)
            //console.log(xScore)
            for (let j = 0; j < 8; j++) {
                nextX.push(nextScore[j] + xScore[j])
            }
            nextO = oScore
        } else {
            //console.log('o turn')
            for (let j = 0; j < 8; j++) {
                nextO.push(nextScore[j] + oScore[j])
            }
            nextX = xScore

        }
        nextNodes[i].push(tempSq)
        nextNodes[i].push(nextX)
        //console.log('next x score is...')
        //console.log(nextX)
        nextNodes[i].push(nextO)
        //console.log(nextO)
        nextNodes[i].push(nextNodeScore)
        //console.log('This new node is')
        //console.log(nextNodes[i])
    }
    //once all nodes are made, apply same method to newly generated nodes.
    //console.log(nextNodes)
    treeNode.push(nextNodes)
    //console.log('Next nodes are:')
    //console.log(treeNode[5])
    //if children exist (further nodes to explore), apply same method to them.
    if (treeNode[5] !== undefined) {
        for (let k = 0; k < nextNodes.length; k++) {
            //console.log('Starting next function call')
            //console.log(treeNode[5][k])
            nextMove(treeNode[5][k])
        }
    }
    return treeNode
}

let treeBase = ['', allSquares, [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], 0]

//this forms a tree that branches into all combations+array structure for analysis.
//console.log(nextMove(treeBase)[5])
console.log('children')
console.log(nextMove(treeBase))
//console.log('All variations are... Should be a factorial')
//console.log(allVariations)